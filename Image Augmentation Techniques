Image Augmentation Techniques ->
Instead of collecting more images, we apply transformations to existing images.
The label/class remains the same; only the image appearance changes.

# Image Augmentation Techniques :

1. **Image Rotation**  
   - Rotating the image by a small angle (e.g., ±15°)

2. **Image Shifting (Translation)**  
   - Moving the image along axes:
     - Horizontal shift (left-right)
     - Vertical shift (up-down)

3. **Image Flipping**  
   - Flipping the image along an axis:
     - Left-Right (horizontal flip)  
     - Up-Down (vertical flip)

4. **Image Noising**  
   - Adding random noise to the image to make the model robust (adding small dots on the image)

5. **Image Blurring**  
   - Slightly blurring the image to simulate focus variations or camera shake

1. Image Rotation :
#import required libraries
from skimage.transform import rotate

#rotating the image by 30 degrees
rotated = rotate(image,angle=30)
#plot the rotated image
print('Rotated Image')
imshow(rotated)

2.Image Shifting (Translation) :
After the shift operation, an object present at location (x,y) in the input image is shifted to a new position (X,Y):
**X = x + dx** 
**Y = y + dy** 

#apply shift operation
from skimage.transform import AffineTransform, warp
transform = AffineTransform(translation=(40,40))
Shift = warp(image,transform)

plt.imshow(Shift)
plt.title('Normal Shift')

Now when we specify mode = 'edge' -> this helps to remove the edges from the images(i.e gaps)
wrapShift = warp(image,transform,mode='edge')

3.Image Flipping :
flipLR = np.fliplr(image)  -> numpy module , we use the 'fliplr' function

#flip image left-to-right
flipLR = np.fliplr(image)

#flip image up-to-down
flipLR = np.flipup(image)

#flip image right-to-left
same as np.fliplr(image)
#flip image down-to-up
same as np.flipup(image)

4.Image Noising :
from skimage.util import random_noise

#add random noise to the image
noisyRandom = random_noise(image,var=0.2) -> var means variant specifies the amount of noise you you want to add.

plt.imshow(noisyRandom)
plt.title('Random Noise')

we can also use a predefined distibution (i.e gaussian distribution)
noisyGaussian = random_noise(image,mode='gaussian')

plt.imshow(noisyGaussian)
plt.title('Gaussian Noise')

5.Image Blurring :
#import required libraries
from skimage.filters import gaussian

#blur the image
blurred = gaussian(image,sigma=2.5,multichannel=True)

plt.imshow(blurred)
plt.title('Blurred Image')

sigma → controls the strength of the blur; higher → more blurred.
multichannel → tells the function the image has multiple color channels (RGB); applies blur to each channel separately.

Question : Which line of code correctly specifies shifting an image by 50 pixels horizontally and 40 pixels vertically using AffineTransform?
Sol : AffineTransform(translation=(50,40))


Using the image Emergency vehicle dataset here ,
tqdm -> from tqdm import tqdm : adds an easy progress bar to loops so you can visually track training or processing progress

example usage -> 
from tqdm import tqdm
import time

for i in tqdm(range(100)):
    time.sleep(0.05)

we can also use in data preprocessing where ->
for epoch in tqdm(range(epochs)):
    train_one_epoch()

the ouput looks like : 
100%|████████████████████████████████| 10/10 [00:03<00:00,  3.02it/s]

Understanding the conversion to numpy array ->
X_train = [img0, img1, img2]
y_train = [0, 1, 2]

X_train = np.array(X_train)
y_train = np.array(y_train)

Output :
(3, 224, 224, 3) -> x_train
(3,)             -> y_train


Till now have reshaped the X before, but in this case we have we need the train and validation sets seperate to add more types of augumented images 
so->
we later manually reshape the X_train , and X_validation, later.
Regular : reshape + split  -> X = X.reshape(X.shape[0], 224*224*3) 
This case : split + reshape(X_train) and reshape(X_validation) -> 
1. final_train = final_train.reshape(final_train.shape[0], 224*224*3)
2. final_train = final_train.reshape(final_train.shape[0], 224*224*3)

Regular : X.min(), X.max() ; X.min(), X.max() -> we fund min max and then normalize it.
This case :   # normalizing the pixel values : img = img/255

Note : 1e^-5 = 10^-5

print('Accuracy on validation set:', accuracy_score(y_valid, np.where(model.predict(final_valid)[:, 0]<0.5, 0, 1))) ->
this step is to mark the values to 0 if the value < 0.5 ; otherwise mark it to 1

Instead of using Augmentation for each transformation, we use ->
Image Augmentation using keras (ImageDataGenerator)

from keras.preprocessing.image import ImageDataGenerator -> import Keras’s image augmentation and preprocessing utility.

image_augmentation = ImageDataGenerator(rotation_range=30, width_shift_range=40, height_shift_range=40,
                              horizontal_flip=True, vertical_flip=True, fill_mode="nearest")
Explanation : 
| Parameter               | What it does                                                                          | Example                      |
| ----------------------- | ------------------------------------------------------------------------------------- | ---------------------------- |
| `rotation_range=30`     | Randomly rotates the image up to **±30°**                                             | Tilts the image left/right   |
| `width_shift_range=40`  | Randomly shifts the image **left/right by up to 40 pixels**                           | Moves the image horizontally |
| `height_shift_range=40` | Randomly shifts the image **up/down by up to 40 pixels**                              | Moves the image vertically   |
| `horizontal_flip=True`  | Randomly flips the image horizontally                                                 | Mirror flip (left ↔ right)   |
| `vertical_flip=True`    | Randomly flips the image vertically                                                   | Flip (top ↔ bottom)          |
| `fill_mode="nearest"`   | Fills in new pixels created after shifting/rotating using **nearest neighbor pixels** | Avoids blank areas           |

then we fit the image augmentation to the train data ->
image_augmentation.fit(X_train)

Note: 2 ways to convert the 2-d, 3-d images to 1-d ->
1. model = Sequential()
model.add(InputLayer(input_shape=(224*224*3,)))

2. model=Sequential()
model.add(InputLayer(input_shape=(224,224,3)))
model.add(Flatten())

both serve the same purpose but the way on doing it is different.






